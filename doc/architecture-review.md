# アーキテクチャレビュー: モノレポ vs マルチレポ

## 現在の構成

### モノレポ構成
現在のリポジトリは**モノレポ（Monorepo）**構成を採用しています。

```
fishing-web-app/
├── backend/          # Spring Boot (Java 21)
├── web/              # React + Vite (TypeScript)
├── doc/              # 設計ドキュメント
├── .devcontainer/    # 開発環境設定
└── docker-compose.yml # 統合環境構成
```

### 技術スタック
- **Backend**: Java 21, Spring Boot 4.0.2, JPA, PostgreSQL
- **Frontend**: React 19, TypeScript, Vite
- **Infrastructure**: Docker Compose（4サービス: dev, backend, web, db）
- **開発環境**: DevContainer（統合開発環境）

### 現在のプロジェクト規模
- **初期段階のMVPプロジェクト**
- Backend: 最小構成（約30行のコード）
- Frontend: 最小構成（約28行のコード）
- 総コード量: 約58行（ボイラープレートを除く実質的なコード）
- コミット履歴: 2コミット（プロジェクト開始直後）

---

## マルチレポへの分割案

### 分割パターン1: フルセパレート（3リポジトリ）
```
1. fishing-web-backend/     # Spring Boot API
2. fishing-web-frontend/    # React SPA
3. fishing-web-infra/       # Docker, IaC, 共通設定
```

### 分割パターン2: コアセパレート（2リポジトリ）
```
1. fishing-web-backend/     # Spring Boot API + DB設計
2. fishing-web-frontend/    # React SPA + 開発環境設定
```

---

## 比較分析

### モノレポのメリット

#### 1. **開発効率（現段階で最大のメリット）**
- 単一クローンで全体を把握可能
- フロントとバックを同時に変更可能（API変更時など）
- 統合開発環境（DevContainer）で一度の起動で全て動作
- docker-compose.ymlで全サービスを一元管理

#### 2. **一貫性の維持**
- コーディング規約、リンター設定を統一管理
- ドキュメントを一箇所に集約（doc/）
- バージョン管理が単純（タグ1つで全体のリリース）

#### 3. **リファクタリングの容易さ**
- API変更時にFE/BEを同一PRで修正可能
- 依存関係の把握が容易
- テストも統合的に実行可能（ATDD: Cucumber + RestAssured）

#### 4. **初期開発での優位性**
- セットアップが簡単（README通りに1リポジトリをクローン）
- 新メンバーのオンボーディングが高速
- 環境差異が生じにくい

### モノレポのデメリット

#### 1. **CI/CDの複雑化（将来的）**
- FE/BE両方のビルドが毎回実行される可能性
- 差分検知でビルドをスキップする仕組みが必要
- デプロイパイプラインが複雑化

#### 2. **権限管理の制約**
- リポジトリ単位での権限分離ができない
- バックエンド専任とフロント専任の権限分けが困難
- GitHub CIの実行時間がプロジェクト全体にカウントされる

#### 3. **スケーラビリティ（大規模化時）**
- コードベースが肥大化すると、クローン・チェックアウトが遅くなる
- 無関係な変更履歴も全て含まれる
- 各コンポーネントの独立リリースが困難

#### 4. **技術選定の柔軟性低下**
- FE/BEで異なるCIツールやワークフローを使いづらい
- 依存関係管理ツールが混在（Maven, npm）

---

### マルチレポのメリット

#### 1. **独立性の向上**
- FE/BEを独立してデプロイ可能
- それぞれのリリースサイクルを自由に設定
- 不具合の影響範囲を限定

#### 2. **CI/CDの最適化**
- 各リポジトリで最適なパイプラインを構築
- ビルド時間の短縮（関連コードのみビルド）
- GitHub Actionsの実行時間を分散

#### 3. **チーム分割との親和性**
- バックエンドチームとフロントエンドチームで独立作業
- リポジトリ単位での権限管理が可能
- コードレビューの範囲が明確

#### 4. **技術的自由度**
- FE/BEで異なる開発環境・ツールを選択可能
- 各レイヤーの技術選定が独立

### マルチレポのデメリット

#### 1. **開発効率の低下（現段階での最大のデメリット）**
- API変更時に2つのリポジトリを跨いで修正
- PRが2つに分かれ、レビューとマージのタイミング調整が必要
- 統合テスト実行が複雑化

#### 2. **セットアップの複雑化**
- 新メンバーは2〜3リポジトリをクローン
- 開発環境の構築手順が増加
- docker-compose.ymlの管理が分散

#### 3. **バージョン管理の複雑化**
- FE/BE間のバージョン互換性管理が必要
- リリースタグの管理が分散
- ロールバック時の調整が煩雑

#### 4. **ドキュメント管理の分散**
- DBスキーマやAPI仕様書の配置場所が不明確
- ドキュメント更新時に複数リポジトリの同期が必要

---

## 推奨事項

### **結論: 現段階ではモノレポ継続を推奨**

#### 理由
1. **プロジェクト初期段階（MVP開発中）**
   - コード量が極めて少ない（約58行）
   - まだアーキテクチャが固まっていない
   - 頻繁にFE/BE間の調整が発生する可能性が高い

2. **開発効率の最大化**
   - 一人または少人数チームでの開発と推測
   - 統合開発環境（DevContainer）が既に整備済み
   - API変更時の同期が容易

3. **マルチレポの利点が活きない**
   - チーム分割の必要性が現時点では低い
   - 独立デプロイの必要性が現時点では低い
   - CI/CD最適化の必要性が現時点では低い

#### マルチレポへの移行を検討すべきタイミング

以下の条件のいずれかを満たした場合、マルチレポへの移行を再検討：

1. **チーム規模の拡大**
   - バックエンド専任とフロント専任に分かれた場合
   - 5名以上のチームになった場合

2. **独立デプロイの必要性**
   - FEとBEのリリース頻度が大きく異なる場合
   - Microservicesアーキテクチャへの移行時

3. **CI/CD時間の肥大化**
   - 全体のビルド時間が10分を超えた場合
   - GitHub Actionsの実行時間制限に抵触した場合

4. **コードベースの肥大化**
   - 各コンポーネントが1万行を超えた場合
   - クローン時間が2分を超えた場合

---

## モノレポ維持のためのベストプラクティス

現在のモノレポ構成を維持しつつ、将来の分割を容易にするための推奨事項：

### 1. **ディレクトリ境界の厳守**
```
backend/  ← バックエンドコードはここのみ
web/      ← フロントエンドコードはここのみ
doc/      ← 共通ドキュメント
```
- 相互参照を禁止（FEからBEのコードを直接参照しない）
- API仕様はOpenAPI（doc/api/）で明文化

### 2. **CI/CDでの差分ビルド**
```yaml
# GitHub Actions例
- name: Check changes
  run: |
    if git diff --name-only HEAD~1 | grep "^backend/"; then
      echo "backend_changed=true" >> $GITHUB_ENV
    fi
```

### 3. **バージョニング戦略**
- 各ディレクトリにバージョンを持たせる
  - backend/pom.xml: `<version>1.0.0</version>`
  - web/package.json: `"version": "1.0.0"`
- リポジトリタグは `v1.0.0-backend`, `v1.0.0-web` で分ける

### 4. **依存関係の明示**
- doc/dependencies.md を作成
- FE/BE間のAPI契約を明記（doc/api-contract.yaml）

---

## まとめ

| 観点 | モノレポ | マルチレポ | 現段階での推奨 |
|------|----------|------------|---------------|
| 開発効率 | ◎ | △ | **モノレポ** |
| 初期セットアップ | ◎ | △ | **モノレポ** |
| チーム分割 | △ | ◎ | **モノレポ** |
| 独立デプロイ | △ | ◎ | **モノレポ** |
| CI/CD最適化 | △ | ◎ | **モノレポ** |
| 現在のコード量での適性 | ◎ | ✗ | **モノレポ** |

**総合判断: モノレポを継続し、上記のベストプラクティスに従って将来の分割を容易にする構造を維持する。**
